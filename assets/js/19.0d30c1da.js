(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{395:function(e,t,a){"use strict";a.r(t);var o=a(26),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),a("h2",{attrs:{id:"value-components"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#value-components"}},[e._v("#")]),e._v(" "),a("em",[e._v("Value components")])]),e._v(" "),a("p",[a("strong",[e._v("Vue-values")]),e._v(" is a library —clearly influenced by "),a("a",{attrs:{href:"https://github.com/ianstormtaylor/react-values",target:"_blank",rel:"noopener noreferrer"}},[e._v("react-values"),a("OutboundLink")],1),e._v("— that allows you to manage simple state values directly within your template without any other scaffolding. That’s perfect for toggles, modals, tooltips, lists, etc. In addition, it provides a simple way to interconnect different "),a("em",[e._v("“stored values”")]),e._v(" to keep them synchronized along your whole app but uncoupled.")]),e._v(" "),a("p",[e._v("In short, any "),a("em",[e._v("Value component")]),e._v(" handles its own value —you only need to declare its "),a("em",[e._v("initial/default")]),e._v(" value— and exposes its current value together with some helper functions to mutate it:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("value")])]),e._v(" "),a("li",[a("code",[e._v("set(newValue)")])]),e._v(" "),a("li",[a("code",[e._v("clear()")]),e._v(": sets the value to the corresponding “empty value” ("),a("em",[e._v("undefined, {}, [], new Set() or new Map()")]),e._v(")")]),e._v(" "),a("li",[a("code",[e._v("reset()")]),e._v(": resets the value to its corresponding "),a("em",[e._v("initial/default")]),e._v(" value.")])]),e._v(" "),a("p",[e._v("There are the following Value components with some of their corresponding helper functions:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Value")])]),e._v(" "),a("li",[a("code",[e._v("BooleanValue")]),e._v(": toggle.")]),e._v(" "),a("li",[a("code",[e._v("NumberValue")]),e._v(": increment, decrement.")]),e._v(" "),a("li",[a("code",[e._v("StringValue")]),e._v(": append, prepend, replace, substring...")]),e._v(" "),a("li",[a("code",[e._v("ArrayValue")]),e._v(": append, prepend, remove, splice, reverse, sort...")]),e._v(" "),a("li",[a("code",[e._v("SetValue")]),e._v(": add, remove, toggle.")]),e._v(" "),a("li",[a("code",[e._v("ObjectValue")]),e._v(": add, remove.")]),e._v(" "),a("li",[a("code",[e._v("MapValue")]),e._v(": add, remove.")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Note")]),e._v(" "),a("p",[e._v("It’s important to mention that every helper function guarantees the correct reactivity of the "),a("em",[e._v("Value component")]),e._v(" itself. That means all of them will set the inner “data” value with a new derived one —and then they never mutate directly the current value—. As an example, the "),a("code",[e._v("ArrayValue")]),e._v("’s reverse function generates a reversed copy of the original one and set the current value with it. So you can use any helper function without worry about reactivity issues.")]),e._v(" "),a("p",[e._v("That’s the reason almost every helper is a function to mutate the value.")])]),e._v(" "),a("h2",{attrs:{id:"stored-and-synchronized-values"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stored-and-synchronized-values"}},[e._v("#")]),e._v(" "),a("em",[e._v("Stored")]),e._v(" and synchronized values")]),e._v(" "),a("p",[e._v("As it’s mentioned at the beginning, you can keep "),a("em",[e._v("Value components")]),e._v(" synchronized with the same common value and even can easily persist them. That is done with the companion "),a("em",[e._v("StoredValue components")]),e._v(". Each "),a("em",[e._v("Value component")]),e._v(" has its own equivalent "),a("code",[e._v("StoredValue")]),e._v(" (you just add the "),a("em",[e._v("“Stored”")]),e._v(" prefix). They behave exactly the same (same props, scoped props and events), but they require a "),a("code",[e._v("uid")]),e._v(" —unique identifier— to identify them.")]),e._v(" "),a("h2",{attrs:{id:"is-this-library-a-substitute-of-vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#is-this-library-a-substitute-of-vuex"}},[e._v("#")]),e._v(" Is this library a substitute of Vuex?")]),e._v(" "),a("p",[e._v("No way! "),a("strong",[a("em",[e._v("Vuex")])]),e._v(" is extremely more powerful, well known and robust. The objective of "),a("em",[e._v("Vue Values")]),e._v(" is simply to experiment different ways to manage simple values when using "),a("em",[e._v("Vuex")]),e._v(" is not necessary.")]),e._v(" "),a("h2",{attrs:{id:"then-when-should-i-use-it"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#then-when-should-i-use-it"}},[e._v("#")]),e._v(" Then, when should I use it?")]),e._v(" "),a("p",[e._v("Well... there are some common circumstances this library can help you:")]),e._v(" "),a("ul",[a("li",[e._v("When you need a simple auxiliary value within your template (for modals, toggles, tooltips, counters, paginators...).")]),e._v(" "),a("li",[e._v("When you need some simple auxiliar value that is present in multiple points of your app. Then it can be useful to keep everything simple and uncoupled but synchronized and even persisted.")])])])}),[],!1,null,null,null);t.default=n.exports}}]);